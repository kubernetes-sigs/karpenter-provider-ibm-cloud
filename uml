@startuml
namespace cache {
    class UnavailableOfferings << (S,Aquamarine) >> {
        - mu sync.RWMutex
        - offerings <font color=blue>map</font>[string]time.Time

        + Add(offeringID string, expiry time.Time) 
        + Remove(offeringID string) 
        + IsUnavailable(offeringID string) bool
        + Cleanup() 

    }
}


namespace cloudprovider {
    class CloudProvider << (S,Aquamarine) >> {
        - kubeClient client.Client
        - recorder events.Recorder
        - instanceTypeProvider instancetype.Provider
        - instanceProvider instance.Provider
        - kubeClient client.Client
        - recorder events.Recorder
        - instanceTypeProvider instancetype.Provider
        - instanceProvider instance.Provider

        - resolveInstanceTypeFromInstance(ctx context.Context, instance *instance.Instance) (*cloudprovider.InstanceType, error)
        - resolveNodePoolFromInstance(ctx context.Context, instance *instance.Instance) (*v1.NodePool, error)
        - resolveNodeClassFromInstance(ctx context.Context, instance *instance.Instance) (*v1alpha1.IBMNodeClass, error)
        - resolveNodeClassFromNodePool(ctx context.Context, nodePool *v1.NodePool) (*v1alpha1.IBMNodeClass, error)
        - instanceToNodeClaim(i *instance.Instance, instanceType *cloudprovider.InstanceType, _ *v1alpha1.IBMNodeClass) *v1.NodeClaim
        - resolveNodeClassFromNodeClaim(ctx context.Context, nodeClaim *v1.NodeClaim) (*v1alpha1.IBMNodeClass, error)
        - resolveInstanceTypes(ctx context.Context, nodeClaim *v1.NodeClaim, nodeClass *v1alpha1.IBMNodeClass) ([]*cloudprovider.InstanceType, error)
        - resolveInstanceTypeFromInstance(ctx context.Context, instance *instance.Instance) (*cloudprovider.InstanceType, error)
        - resolveNodePoolFromInstance(ctx context.Context, instance *instance.Instance) (*v1.NodePool, error)
        - resolveNodeClassFromInstance(ctx context.Context, instance *instance.Instance) (*v1alpha1.ECSNodeClass, error)
        - resolveNodeClassFromNodePool(ctx context.Context, nodePool *v1.NodePool) (*v1alpha1.ECSNodeClass, error)
        - instanceToNodeClaim(i *instance.Instance, instanceType *cloudprovider.InstanceType, _ *v1alpha1.ECSNodeClass) *v1.NodeClaim
        - resolveNodeClassFromNodeClaim(ctx context.Context, nodeClaim *v1.NodeClaim) (*v1alpha1.ECSNodeClass, error)
        - resolveInstanceTypes(ctx context.Context, nodeClaim *v1.NodeClaim, nodeClass *v1alpha1.ECSNodeClass) ([]*cloudprovider.InstanceType, error)

        + Create(ctx context.Context, nodeClaim *v1.NodeClaim) (*v1.NodeClaim, error)
        + List(ctx context.Context) ([]*v1.NodeClaim, error)
        + Get(ctx context.Context, providerID string) (*v1.NodeClaim, error)
        + LivenessProbe(req *http.Request) error
        + GetInstanceTypes(ctx context.Context, nodePool *v1.NodePool) ([]*cloudprovider.InstanceType, error)
        + Delete(ctx context.Context, nodeClaim *v1.NodeClaim) error
        + IsDrifted(ctx context.Context, nodeClaim *v1.NodeClaim) (cloudprovider.DriftReason, error)
        + Name() string
        + GetSupportedNodeClasses() []status.Object
        + Create(ctx context.Context, nodeClaim *v1.NodeClaim) (*v1.NodeClaim, error)
        + List(ctx context.Context) ([]*v1.NodeClaim, error)
        + Get(ctx context.Context, providerID string) (*v1.NodeClaim, error)
        + LivenessProbe(req *http.Request) error
        + GetInstanceTypes(ctx context.Context, nodePool *v1.NodePool) ([]*cloudprovider.InstanceType, error)
        + Delete(ctx context.Context, nodeClaim *v1.NodeClaim) error
        + IsDrifted(ctx context.Context, nodeClaim *v1.NodeClaim) (cloudprovider.DriftReason, error)
        + Name() string
        + GetSupportedNodeClasses() []status.Object

    }
}


namespace ibmcloud {
    class CloudProvider << (S,Aquamarine) >> {
        - kubeClient client.Client
        - ibmClient *ibm.Client
        - instanceTypes []*cloudprovider.InstanceType

        - toNode(nodeClaim *v1.NodeClaim, instanceID string) (*v1.Node, error)
        - getInstanceType(name string) (*cloudprovider.InstanceType, error)
        - instanceToNodeClaim(instance *ibm.Instance) (*v1.NodeClaim, error)

        + Create(ctx context.Context, nodeClaim *v1.NodeClaim) (*v1.NodeClaim, error)
        + Delete(ctx context.Context, nodeClaim *v1.NodeClaim) error
        + Get(ctx context.Context, providerID string) (*v1.NodeClaim, error)
        + List(ctx context.Context) ([]*v1.NodeClaim, error)
        + GetInstanceTypes(ctx context.Context, nodePool *v1.NodePool) ([]*cloudprovider.InstanceType, error)
        + DisruptionReasons() []v1.DisruptionReason
        + IsDrifted(ctx context.Context, nodeClaim *v1.NodeClaim) (cloudprovider.DriftReason, error)
        + Name() string
        + GetSupportedNodeClasses() []status.Object

    }
}


namespace main {
    class IBMCloudReconciler << (S,Aquamarine) >> {
        + CloudProvider *cloudprovider.CloudProvider

        + Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error)

    }
    class IBMInstanceType << (S,Aquamarine) >> {
        + Name string
        + Architecture string
        + OperatingSystems []v1.OSName
        + Resources v1.ResourceList
        + Offerings []IBMOffering

    }
    class IBMOffering << (S,Aquamarine) >> {
        + Requirements []v1.NodeSelectorRequirement
        + Offering cloudprovider.Offering

    }
}
"client.Client" *-- "main.IBMCloudReconciler"


namespace pricing {
    class Price << (S,Aquamarine) >> {
        + InstanceType string
        + Zone string
        + HourlyPrice float64
        + Currency string

    }
    interface Provider  {
        + GetPrice(ctx context.Context, instanceType string, zone string) (float64, error)
        + GetPrices(ctx context.Context, zone string) (<font color=blue>map</font>[string]float64, error)
        + Refresh(ctx context.Context) error

    }
}


namespace v1alpha1 {
    class IBMNodeClass << (S,Aquamarine) >> {
        + Status IBMNodeClassStatus
        + Spec IBMNodeClassSpec
        + Status IBMNodeClassStatus

        + StatusConditions() status.ConditionSet
        + GetConditions() []status.Condition
        + SetConditions(conditions []status.Condition) 
        + DeepCopyInto(out *IBMNodeClass) 
        + DeepCopy() *IBMNodeClass
        + DeepCopyObject() runtime.Object

    }
    class IBMNodeClassList << (S,Aquamarine) >> {
        + Items []IBMNodeClass
        + Items []IBMNodeClass

        + DeepCopyInto(out *IBMNodeClassList) 
        + DeepCopy() *IBMNodeClassList
        + DeepCopyObject() runtime.Object

    }
    class IBMNodeClassSpec << (S,Aquamarine) >> {
        + Region string
        + Zone string
        + InstanceProfile string
        + Image string
        + VPC string
        + Subnet string
        + SecurityGroups []string
        + Tags <font color=blue>map</font>[string]string

    }
    class IBMNodeClassStatus << (S,Aquamarine) >> {
        + Conditions []status.Condition
        + SpecHash uint64

        + DeepCopyInto(out *IBMNodeClassStatus) 
        + DeepCopy() *IBMNodeClassStatus

    }
}
"v1.ObjectMeta" *-- "v1alpha1.IBMNodeClass"
"v1.TypeMeta" *-- "v1alpha1.IBMNodeClass"
"v1.ListMeta" *-- "v1alpha1.IBMNodeClassList"
"v1.TypeMeta" *-- "v1alpha1.IBMNodeClassList"


@enduml
